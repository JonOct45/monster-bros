"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var P = _interopRequireWildcard(require("@react-pdf/primitives"));

var _fns = require("@react-pdf/fns");

var _renderPath = _interopRequireDefault(require("./renderPath"));

var _renderRect = _interopRequireDefault(require("./renderRect"));

var _renderLine = _interopRequireDefault(require("./renderLine"));

var _renderGroup = _interopRequireDefault(require("./renderGroup"));

var _renderCircle = _interopRequireDefault(require("./renderCircle"));

var _renderSvgText = _interopRequireDefault(require("./renderSvgText"));

var _renderEllipse = _interopRequireDefault(require("./renderEllipse"));

var _renderPolygon = _interopRequireDefault(require("./renderPolygon"));

var _renderPolyline = _interopRequireDefault(require("./renderPolyline"));

var _renderSvgImage = _interopRequireDefault(require("./renderSvgImage"));

var _clipNode = _interopRequireDefault(require("../operations/clipNode"));

var _transform = _interopRequireDefault(require("../operations/transform"));

var _getBoundingBox = _interopRequireDefault(require("../svg/getBoundingBox"));

var _renderFns;

var setStrokeWidth = function setStrokeWidth(ctx, node) {
  var _node$props;

  var lineWidth = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;
  if (lineWidth) ctx.lineWidth(lineWidth);
};

var setStrokeColor = function setStrokeColor(ctx, node) {
  var _node$props2;

  var strokeColor = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;
  if (strokeColor) ctx.strokeColor(strokeColor);
};

var setOpacity = function setOpacity(ctx, node) {
  var _node$props3;

  var opacity = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;
  if (!(0, _fns.isNil)(opacity)) ctx.opacity(opacity);
};

var setFillOpacity = function setFillOpacity(ctx, node) {
  var _node$props4;

  var fillOpacity = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;
  if (!(0, _fns.isNil)(fillOpacity)) ctx.fillOpacity(fillOpacity);
};

var setStrokeOpacity = function setStrokeOpacity(ctx, node) {
  var _node$props5;

  var strokeOpacity = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;
  if (!(0, _fns.isNil)(strokeOpacity)) ctx.strokeOpacity(strokeOpacity);
};

var setLineJoin = function setLineJoin(ctx, node) {
  var _node$props6;

  var lineJoin = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;
  if (lineJoin) ctx.lineJoin(lineJoin);
};

var setLineCap = function setLineCap(ctx, node) {
  var _node$props7;

  var lineCap = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;
  if (lineCap) ctx.lineCap(lineCap);
};

var setLineDash = function setLineDash(ctx, node) {
  var _node$props8;

  var value = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;
  if (value) ctx.dash(value.split(','));
};

var hasLinearGradientFill = function hasLinearGradientFill(node) {
  var _node$props9, _node$props9$fill;

  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === P.LinearGradient;
};

var hasRadialGradientFill = function hasRadialGradientFill(node) {
  var _node$props10, _node$props10$fill;

  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === P.RadialGradient;
}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104


var setLinearGradientFill = function setLinearGradientFill(ctx, node) {
  var _node$props11;

  var bbox = (0, _getBoundingBox.default)(node);
  var gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;
  var x1 = gradient.props.x1 || 0;
  var y1 = gradient.props.y1 || 0;
  var x2 = gradient.props.x2 || 1;
  var y2 = gradient.props.y2 || 0;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gx1 = m0 * x1 + m4;
  var gy1 = m3 * y1 + m5;
  var gx2 = m0 * x2 + m4;
  var gy2 = m3 * y2 + m5;
  var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);
  gradient.children.forEach(function (stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155


var setRadialGradientFill = function setRadialGradientFill(ctx, node) {
  var _node$props12;

  var bbox = (0, _getBoundingBox.default)(node);
  var gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;
  var cx = gradient.props.cx || 0.5;
  var cy = gradient.props.cy || 0.5;
  var fx = gradient.props.fx || cx;
  var fy = gradient.props.fy || cy;
  var r = gradient.props.r || 0.5;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gr = r * m0;
  var gcx = m0 * cx + m4;
  var gcy = m3 * cy + m5;
  var gfx = m0 * fx + m4;
  var gfy = m3 * fy + m5;
  var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);
  gradient.children.forEach(function (stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};

var setFillColor = function setFillColor(ctx, node) {
  var _node$props13;

  var fillColor = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;
  if (fillColor) ctx.fillColor(fillColor);
};

var setFill = function setFill(ctx, node) {
  if (hasLinearGradientFill(node)) return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node)) return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};

var draw = function draw(ctx, node) {
  var props = node.props || {};

  if (props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if (props.fill) {
    ctx.fill(props.fillRule);
  } else if (props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};

var noop = function noop() {};

var renderFns = (_renderFns = {}, _renderFns[P.Tspan] = noop, _renderFns[P.TextInstance] = noop, _renderFns[P.Path] = _renderPath.default, _renderFns[P.Rect] = _renderRect.default, _renderFns[P.Line] = _renderLine.default, _renderFns[P.G] = _renderGroup.default, _renderFns[P.Text] = _renderSvgText.default, _renderFns[P.Circle] = _renderCircle.default, _renderFns[P.Image] = _renderSvgImage.default, _renderFns[P.Ellipse] = _renderEllipse.default, _renderFns[P.Polygon] = _renderPolygon.default, _renderFns[P.Polyline] = _renderPolyline.default, _renderFns);

var renderNode = function renderNode(ctx, node) {
  var renderFn = renderFns[node.type];

  if (renderFns) {
    renderFn(ctx, node);
  } else {
    console.warn("SVG node of type " + node.type + " is not currenty supported");
  }
};

var drawNode = function drawNode(ctx, node) {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  (0, _transform.default)(ctx, node);
  renderNode(ctx, node);
  draw(ctx, node);
};

var clipPath = function clipPath(ctx, node) {
  var _node$props14;

  var value = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;

  if (value) {
    var children = value.children || [];
    children.forEach(function (child) {
      return renderNode(ctx, child);
    });
    ctx.clip();
  }
};

var drawChildren = function drawChildren(ctx, node) {
  var children = node.children || [];
  children.forEach(function (child) {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren(ctx, child);
    ctx.restore();
  });
};

var resolveAspectRatio = function resolveAspectRatio(ctx, node) {
  var _node$box = node.box,
      width = _node$box.width,
      height = _node$box.height;
  var _node$props15 = node.props,
      viewBox = _node$props15.viewBox,
      _node$props15$preserv = _node$props15.preserveAspectRatio,
      preserveAspectRatio = _node$props15$preserv === void 0 ? {} : _node$props15$preserv;
  var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice,
      meetOrSlice = _preserveAspectRatio$ === void 0 ? 'meet' : _preserveAspectRatio$,
      _preserveAspectRatio$2 = preserveAspectRatio.align,
      align = _preserveAspectRatio$2 === void 0 ? 'xMidYMid' : _preserveAspectRatio$2;
  if (viewBox == null || width == null || height == null) return;
  var x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;
  var y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;
  var logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;
  var logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height;
  var logicalRatio = logicalWidth / logicalHeight;
  var physicalRatio = width / height;
  var scaleX = width / logicalWidth;
  var scaleY = height / logicalHeight;

  if (align === 'none') {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y);
    return;
  }

  if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {
    ctx.scale(scaleY, scaleY);

    switch (align) {
      case 'xMinYMin':
      case 'xMinYMid':
      case 'xMinYMax':
        ctx.translate(-x, -y);
        break;

      case 'xMidYMin':
      case 'xMidYMid':
      case 'xMidYMax':
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);
        break;

      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);
    }
  } else {
    ctx.scale(scaleX, scaleX);

    switch (align) {
      case 'xMinYMin':
      case 'xMidYMin':
      case 'xMaxYMin':
        ctx.translate(-x, -y);
        break;

      case 'xMinYMid':
      case 'xMidYMid':
      case 'xMaxYMid':
        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);
        break;

      default:
        ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));
    }
  }
};

var moveToOrigin = function moveToOrigin(ctx, node) {
  var _node$box2 = node.box,
      top = _node$box2.top,
      left = _node$box2.left;
  var paddingLeft = node.box.paddingLeft || 0;
  var paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};

var renderSvg = function renderSvg(ctx, node) {
  ctx.save();
  (0, _clipNode.default)(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};

var _default = renderSvg;
exports.default = _default;