"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

exports.__esModule = true;
exports.default = void 0;

var P = _interopRequireWildcard(require("@react-pdf/primitives"));

var _stylesheet = require("@react-pdf/stylesheet");

var _fns = require("@react-pdf/fns");

var _layoutText = _interopRequireDefault(require("../svg/layoutText"));

var _replaceDefs = _interopRequireDefault(require("../svg/replaceDefs"));

var _getContainer = _interopRequireDefault(require("../svg/getContainer"));

var _parseViewbox = _interopRequireDefault(require("../svg/parseViewbox"));

var _inheritProps = _interopRequireDefault(require("../svg/inheritProps"));

var _parseAspectRatio = _interopRequireDefault(require("../svg/parseAspectRatio"));

var STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];
var VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];
var HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];

var isType = function isType(type) {
  return function (node) {
    return node.type === type;
  };
};

var isSvg = isType(P.Svg);
var isText = isType(P.Text);
var isTextInstance = isType(P.TextInstance);

var transformPercent = function transformPercent(container) {
  return function (props) {
    return (0, _fns.mapValues)(props, function (value, key) {
      var match = (0, _fns.matchPercent)(value);

      if (match && VERTICAL_PROPS.includes(key)) {
        return match.percent * container.height;
      }

      if (match && HORIZONTAL_PROPS.includes(key)) {
        return match.percent * container.width;
      }

      return value;
    });
  };
};

var parsePercent = function parsePercent(value) {
  var match = (0, _fns.matchPercent)(value);
  return match ? match.percent : parseFloat(value);
};

var parseProps = function parseProps(container) {
  return function (node) {
    var props = transformPercent(container)(node.props);
    props = (0, _fns.evolve)({
      x: parseFloat,
      x1: parseFloat,
      x2: parseFloat,
      y: parseFloat,
      y1: parseFloat,
      y2: parseFloat,
      r: parseFloat,
      rx: parseFloat,
      ry: parseFloat,
      cx: parseFloat,
      cy: parseFloat,
      width: parseFloat,
      height: parseFloat,
      offset: parsePercent,
      fill: _stylesheet.transformColor,
      opacity: parsePercent,
      stroke: _stylesheet.transformColor,
      stopOpacity: parsePercent,
      stopColor: _stylesheet.transformColor,
      transform: _stylesheet.processTransform
    }, props);
    return Object.assign({}, node, {
      props: props
    });
  };
};

var mergeStyles = function mergeStyles(node) {
  var style = node.style || {};
  var props = Object.assign({}, style, node.props);
  return Object.assign({}, node, {
    props: props
  });
};

var removeNoneValues = function removeNoneValues(node) {
  var removeNone = function removeNone(value) {
    return value === 'none' ? null : value;
  };

  var props = (0, _fns.mapValues)(node.props, removeNone);
  return Object.assign({}, node, {
    props: props
  });
};

var pickStyleProps = function pickStyleProps(node) {
  var props = node.props || {};
  var styleProps = (0, _fns.pick)(STYLE_PROPS, props);
  var style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, {
    style: style
  });
};

var parseSvgProps = function parseSvgProps(node) {
  var props = (0, _fns.evolve)({
    width: parseFloat,
    height: parseFloat,
    viewBox: _parseViewbox.default,
    preserveAspectRatio: _parseAspectRatio.default
  }, node.props);
  return Object.assign({}, node, {
    props: props
  });
};

var wrapBetweenTspan = function wrapBetweenTspan(node) {
  return {
    type: P.Tspan,
    props: {},
    children: [node]
  };
};

var addMissingTspan = function addMissingTspan(node) {
  if (!isText(node)) return node;
  if (!node.children) return node;

  var resolveChild = function resolveChild(child) {
    return isTextInstance(child) ? wrapBetweenTspan(child) : child;
  };

  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children: children
  });
};

var parseText = function parseText(fontStore) {
  return function (node) {
    if (isText(node)) return (0, _layoutText.default)(fontStore, node);
    if (!node.children) return node;
    var children = node.children.map(parseText(fontStore));
    return Object.assign({}, node, {
      children: children
    });
  };
};

var resolveSvgNode = function resolveSvgNode(container) {
  return (0, _fns.compose)(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles);
};

var resolveChildren = function resolveChildren(container) {
  return function (node) {
    if (!node.children) return node;
    var resolveChild = (0, _fns.compose)(resolveChildren(container), resolveSvgNode(container));
    var children = node.children.map(resolveChild);
    return Object.assign({}, node, {
      children: children
    });
  };
};

var resolveSvgRoot = function resolveSvgRoot(node, fontStore) {
  var container = (0, _getContainer.default)(node);
  return (0, _fns.compose)(_replaceDefs.default, parseText(fontStore), parseSvgProps, pickStyleProps, _inheritProps.default, resolveChildren(container))(node);
};
/**
 * Pre-process SVG nodes so they can be rendered in the next steps
 *
 * @param {Object} root node
 * @param {Object} fontStore font store
 * @returns {Object} root node
 */


var resolveSvg = function resolveSvg(node, fontStore) {
  if (!node.children) return node;

  var resolveChild = function resolveChild(child) {
    return resolveSvg(child, fontStore);
  };

  var root = isSvg(node) ? resolveSvgRoot(node, fontStore) : node;
  var children = root.children.map(resolveChild);
  return Object.assign({}, root, {
    children: children
  });
};

var _default = resolveSvg;
exports.default = _default;