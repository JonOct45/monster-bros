"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;

exports.__esModule = true;
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var P = _interopRequireWildcard(require("@react-pdf/primitives"));

var _fns = require("@react-pdf/fns");

var _isFixed = _interopRequireDefault(require("../node/isFixed"));

var _splitText = _interopRequireDefault(require("../text/splitText"));

var _splitNode2 = _interopRequireDefault(require("../node/splitNode"));

var _getWrap = _interopRequireDefault(require("../node/getWrap"));

var _getWrapArea = _interopRequireDefault(require("../page/getWrapArea"));

var _getContentArea = _interopRequireDefault(require("../page/getContentArea"));

var _createInstance = _interopRequireDefault(require("../node/createInstance"));

var _shouldBreak = _interopRequireDefault(require("../node/shouldBreak"));

var _resolveTextLayout = _interopRequireDefault(require("./resolveTextLayout"));

var _resolveInheritance = _interopRequireDefault(require("./resolveInheritance"));

var _resolveDimensions = require("./resolveDimensions");

/* eslint-disable no-continue */

/* eslint-disable prefer-destructuring */
var isText = function isText(node) {
  return node.type === P.Text;
}; // Prevent splitting elements by low decimal numbers


var SAFTY_THRESHOLD = 0.001;

var assingChildren = function assingChildren(children, node) {
  return Object.assign({}, node, {
    children: children
  });
};

var getTop = function getTop(node) {
  var _node$box;

  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};

var allFixed = function allFixed(nodes) {
  return nodes.every(_isFixed.default);
};

var isDynamic = function isDynamic(node) {
  var _node$props;

  return !(0, _fns.isNil)((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);
};

var relayoutPage = (0, _fns.compose)(_resolveTextLayout.default, _resolveInheritance.default, _resolveDimensions.resolvePageDimensions);

var warnUnavailableSpace = function warnUnavailableSpace(node) {
  console.warn("Node of type " + node.type + " can't wrap between pages and it's bigger than available page height");
};

var splitNodes = function splitNodes(height, contentArea, nodes) {
  var currentChildren = [];
  var nextChildren = [];

  for (var i = 0; i < nodes.length; i += 1) {
    var child = nodes[i];
    var futureNodes = nodes.slice(i + 1);
    var futureFixedNodes = futureNodes.filter(_isFixed.default);
    var nodeTop = getTop(child);
    var nodeHeight = child.box.height;
    var isOutside = height <= nodeTop;
    var shouldBreak = (0, _shouldBreak.default)(child, futureNodes, height);
    var shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;
    var canWrap = (0, _getWrap.default)(child);
    var fitsInsidePage = nodeHeight <= contentArea;

    if ((0, _isFixed.default)(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }

    if (isOutside) {
      var box = Object.assign({}, child.box, {
        top: child.box.top - height
      });
      var next = Object.assign({}, child, {
        box: box
      });
      nextChildren.push(next);
      continue;
    }

    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push.apply(nextChildren, futureNodes);
      warnUnavailableSpace(child);
      break;
    }

    if (shouldBreak) {
      var _box = Object.assign({}, child.box, {
        top: child.box.top - height
      });

      var props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });

      var _next = Object.assign({}, child, {
        box: _box,
        props: props
      });

      currentChildren.push.apply(currentChildren, futureFixedNodes);
      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));
      break;
    }

    if (shouldSplit) {
      var _split = split(child, height, contentArea),
          currentChild = _split[0],
          nextChild = _split[1];

      if (currentChild) currentChildren.push(currentChild);
      if (nextChild) nextChildren.push(nextChild);
      continue;
    }

    currentChildren.push(child);
  }

  return [currentChildren, nextChildren];
};

var splitChildren = function splitChildren(height, contentArea, node) {
  var children = node.children || [];
  var availableHeight = height - getTop(node);
  return splitNodes(availableHeight, contentArea, children);
};

var splitView = function splitView(node, height, contentArea) {
  var _splitNode = (0, _splitNode2.default)(node, height),
      currentNode = _splitNode[0],
      nextNode = _splitNode[1];

  var _splitChildren = splitChildren(height, contentArea, node),
      currentChilds = _splitChildren[0],
      nextChildren = _splitChildren[1];

  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];
};

var split = function split(node, height, contentArea) {
  return isText(node) ? (0, _splitText.default)(node, height) : splitView(node, height, contentArea);
};

var shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {
  var children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes);
};

var resolveDynamicNodes = function resolveDynamicNodes(props, node) {
  var isNodeDynamic = isDynamic(node); // Call render prop on dynamic nodes and append result to children

  var resolveChildren = function resolveChildren(children) {
    if (children === void 0) {
      children = [];
    }

    if (isNodeDynamic) {
      var res = node.props.render(props);
      return [(0, _createInstance.default)(res)].filter(Boolean);
    }

    return children.map(function (c) {
      return resolveDynamicNodes(props, c);
    });
  }; // We reset dynamic text box so it can be computed again later on


  var resetHeight = isNodeDynamic && isText(node);
  var box = resetHeight ? (0, _extends2.default)({}, node.box, {
    height: 0
  }) : node.box;
  var children = resolveChildren(node.children);
  var lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, {
    box: box,
    lines: lines,
    children: children
  });
};

var resolveDynamicPage = function resolveDynamicPage(props, page, fontStore) {
  if (shouldResolveDynamicNodes(page)) {
    var resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore);
  }

  return page;
};

var splitPage = function splitPage(page, pageNumber, fontStore) {
  var wrapArea = (0, _getWrapArea.default)(page);
  var contentArea = (0, _getContentArea.default)(page);
  var dynamicPage = resolveDynamicPage({
    pageNumber: pageNumber
  }, page, fontStore);
  var height = page.style.height;

  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children),
      currentChilds = _splitNodes[0],
      nextChilds = _splitNodes[1];

  var relayout = function relayout(node) {
    return relayoutPage(node, fontStore);
  };

  var currentBox = (0, _extends2.default)({}, page.box, {
    height: height
  });
  var currentPage = relayout(Object.assign({}, page, {
    box: currentBox,
    children: currentChilds
  }));
  if (nextChilds.length === 0 || allFixed(nextChilds)) return [currentPage, null];
  var nextBox = (0, _fns.omit)('height', page.box);
  var nextPage = relayout(Object.assign({}, page, {
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};

var resolvePageIndices = function resolvePageIndices(fontStore, page, pageNumber, pages) {
  var totalPages = pages.length;
  var props = {
    totalPages: totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore);
};

var assocSubPageData = function assocSubPageData(subpages) {
  return subpages.map(function (page, i) {
    return (0, _extends2.default)({}, page, {
      subPageNumber: i,
      subPageTotalPages: subpages.length
    });
  });
};

var dissocSubPageData = function dissocSubPageData(page) {
  return (0, _fns.omit)(['subPageNumber', 'subPageTotalPages'], page);
};

var paginate = function paginate(page, pageNumber, fontStore) {
  if (!page) return [];
  var splittedPage = splitPage(page, pageNumber, fontStore);
  var pages = [splittedPage[0]];
  var nextPage = splittedPage[1];

  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }

  return pages;
};
/**
 * Performs pagination. This is the step responsible of breaking the whole document
 * into pages following pagiation rules, such as `fixed`, `break` and dynamic nodes.
 *
 * @param {Object} node
 * @param {Object} fontStore font store
 * @returns {Object} layout node
 */


var resolvePagination = function resolvePagination(doc, fontStore) {
  var pages = [];
  var pageNumber = 1;

  for (var i = 0; i < doc.children.length; i += 1) {
    var page = doc.children[i];
    var subpages = paginate(page, pageNumber, fontStore);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }

  pages = pages.map(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return dissocSubPageData(resolvePageIndices.apply(void 0, [fontStore].concat(args)));
  });
  return assingChildren(pages, doc);
};

var _default = resolvePagination;
exports.default = _default;